<!DOCTYPE html>

<html>
<head>
  <title>refine_linearrefinegt.go</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="core_binaryreconcile.html">
                core_binaryreconcile.go
              </a>
            
              
              <a class="source" href="core_genetree.html">
                core_genetree.go
              </a>
            
              
              <a class="source" href="core_node.html">
                core_node.go
              </a>
            
              
              <a class="source" href="core_rf.html">
                core_rf.go
              </a>
            
              
              <a class="source" href="core_speciestree.html">
                core_speciestree.go
              </a>
            
              
              <a class="source" href="core_test.html">
                core_test.go
              </a>
            
              
              <a class="source" href="core_tree.html">
                core_tree.go
              </a>
            
              
              <a class="source" href="refine_linearrefinegt.html">
                refine_linearrefinegt.go
              </a>
            
              
              <a class="source" href="refine_misc.html">
                refine_misc.go
              </a>
            
              
              <a class="source" href="refine_test.html">
                refine_test.go
              </a>
            
              
              <a class="source" href="refine_weightgt.html">
                refine_weightgt.go
              </a>
            
              
              <a class="source" href="refine_weightgt_test.html">
                refine_weightgt_test.go
              </a>
            
              
              <a class="source" href="test_misc.html">
                test_misc.go
              </a>
            
              
              <a class="source" href="util_contract.html">
                util_contract.go
              </a>
            
              
              <a class="source" href="util_prune.html">
                util_prune.go
              </a>
            
              
              <a class="source" href="util_simu.html">
                util_simu.go
              </a>
            
              
              <a class="source" href="util_test.html">
                util_test.go
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>refine_linearrefinegt.go</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">package</span> tree

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"errors"</span>
	<span class="hljs-string">"sort"</span>
)

<span class="hljs-keyword">type</span> InvalidMethodError <span class="hljs-keyword">struct</span> {
	Method <span class="hljs-typename">string</span>
}

<span class="hljs-keyword">func</span> (err InvalidMethodError) Error() <span class="hljs-typename">string</span> {
	<span class="hljs-keyword">return</span> <span class="hljs-string">"Invalid method: "</span> + err.Method
}

<span class="hljs-keyword">var</span> (
	NotEnoughWeightsError     = errors.New(<span class="hljs-string">"Not enough weight parameters."</span>)
	NotBinarySpeciesTreeError = errors.New(<span class="hljs-string">"Species tree is not binary."</span>)
)</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A dispatch function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">func</span> RefineGt(gt *Tree, st *SpeciesTree, method <span class="hljs-typename">string</span>, weights ...<span class="hljs-typename">float64</span>) error {
	<span class="hljs-keyword">var</span> refine <span class="hljs-keyword">func</span>(*Node)
	<span class="hljs-keyword">switch</span> method {
	<span class="hljs-keyword">case</span> <span class="hljs-string">"duploss"</span>:
		refine = minDupThenLoss
	<span class="hljs-keyword">case</span> <span class="hljs-string">"mutation"</span>:
		refine = minDupPlusLoss
	<span class="hljs-keyword">case</span> <span class="hljs-string">"lossdup"</span>:
		refine = minLossThenDup
	<span class="hljs-keyword">case</span> <span class="hljs-string">"weighted"</span>:
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(weights) &lt;<span class="hljs-number"> 2</span> {
			<span class="hljs-keyword">return</span> NotEnoughWeightsError
		}
		refine = weightedCost(weights<span class="hljs-number">[0</span>], weights<span class="hljs-number">[1</span>])
	<span class="hljs-keyword">case</span> <span class="hljs-string">"affine"</span>:
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(weights) &lt;<span class="hljs-number"> 2</span> {
			<span class="hljs-keyword">return</span> NotEnoughWeightsError
		}
		refine = affineCost(weights<span class="hljs-number">[0</span>], weights<span class="hljs-number">[1</span>])
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> InvalidMethodError{method} <span class="hljs-comment">// This shouldn't happen.</span>
	}
	err := refineGt(gt, st, refine)
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> err
	}
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}

<span class="hljs-keyword">func</span> refineGt(gt *Tree, st *SpeciesTree, refine <span class="hljs-keyword">func</span>(*Node)) error {
	<span class="hljs-keyword">if</span> !st.IsBinary() {
		<span class="hljs-keyword">return</span> NotBinarySpeciesTreeError
	}
	<span class="hljs-keyword">if</span> gt.IsBinary() {
		<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
	}

	sl := st.Nodes
	gl := gt.Nodes

	lm, err := LcaMap(gt, st)
	lca := st.Lca
	<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
		<span class="hljs-keyword">return</span> err
	}
	M := lm.Map</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>1) find the pre-image <code>pre[s]</code> of every species
node s under LCA mapping.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	pre := <span class="hljs-built_in">make</span>([][]*Node, <span class="hljs-built_in">len</span>(sl))</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p><code>d[node.Id]</code>: index of node in <code>node.Father.Children</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	d := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, <span class="hljs-built_in">len</span>(gl))
	<span class="hljs-keyword">var</span> sid <span class="hljs-typename">int</span>
	<span class="hljs-keyword">for</span> i, gn := <span class="hljs-keyword">range</span> gl {
		<span class="hljs-keyword">if</span> gn.IsInternal() {
			<span class="hljs-keyword">for</span> j, c := <span class="hljs-keyword">range</span> gn.Children {
				d[c.Id] = j
			}
		}

		sid = M[i].Id
		pre[sid] = <span class="hljs-built_in">append</span>(pre[sid], gn)
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>2) reorder the children of every non-binary
gene tree node by swaping the children i and j</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	swap := <span class="hljs-keyword">func</span>(children []*Node, i, j <span class="hljs-typename">int</span>) {
		children[i], children[j] = children[j], children[i]
		d[children[i].Id] = i
		d[children[j].Id] = j
	}

	ind := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, <span class="hljs-built_in">len</span>(gl))
	<span class="hljs-keyword">var</span> fn *Node
	<span class="hljs-keyword">for</span> _, sn := <span class="hljs-keyword">range</span> sl {
		<span class="hljs-keyword">for</span> _, gn := <span class="hljs-keyword">range</span> pre[sn.Id] {
			fn = gn.Father
			<span class="hljs-keyword">if</span> fn == <span class="hljs-constant">nil</span> {
				<span class="hljs-keyword">break</span>
			}
			<span class="hljs-keyword">if</span> !fn.IsBinary() {
				swap(fn.Children, ind[fn.Id], d[gn.Id])
				ind[fn.Id]++
			}
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>3) for every non-binary gene tree node g
find every node <code>s</code> in <code>I^*(g)</code>, make a copy <code>s&#39;</code> of <code>s</code>,
and set <code>s&#39;.Father = g</code>.</p>
<p>If <code>g_i</code> maps to <code>s</code>, then append <code>g_i</code> to <code>s&#39;.Ext</code>.</p>
<p>Finally, append <code>s&#39;</code> to <code>b[s]</code> (<code>b[s.Id]</code> in fact).
Notice that we just use <code>s&#39;.Father</code> to store <code>g</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
	makeCopy := <span class="hljs-keyword">func</span>(t *Node) *Node {
		n := &amp;Node{&amp;data{}, <span class="hljs-constant">nil</span>, <span class="hljs-constant">nil</span>}
		n.Name = t.Name
		n.Level = t.Level
		<span class="hljs-keyword">return</span> n
	}

	appendCopy := <span class="hljs-keyword">func</span>(t *Node, l []*Node, c *Node, leaf <span class="hljs-typename">bool</span>) []*Node {
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(l) ==<span class="hljs-number"> 0</span> || l[<span class="hljs-built_in">len</span>(l<span class="hljs-number">)-1</span>].Father != c.Father {
			n := makeCopy(t)
			n.Father = c.Father
			l = <span class="hljs-built_in">append</span>(l, n)
		}
		<span class="hljs-keyword">if</span> leaf {
			n := l[<span class="hljs-built_in">len</span>(l<span class="hljs-number">)-1</span>]
			<span class="hljs-keyword">if</span> n.Ext != <span class="hljs-constant">nil</span> {
				n.Ext = <span class="hljs-built_in">append</span>(n.Ext.([]*Node), c)
			} <span class="hljs-keyword">else</span> {
				n.Ext = []*Node{c}
			}
		}
		<span class="hljs-keyword">if</span> l[<span class="hljs-built_in">len</span>(l<span class="hljs-number">)-1</span>].Father != c.Father {
			<span class="hljs-keyword">if</span> c.Father == <span class="hljs-constant">nil</span> {
				<span class="hljs-built_in">panic</span>(<span class="hljs-string">"What!"</span>)
			}
		}
		<span class="hljs-keyword">return</span> l
	}

	b := <span class="hljs-built_in">make</span>([][]*Node, <span class="hljs-built_in">len</span>(sl))
	<span class="hljs-keyword">var</span> tn *Node
	<span class="hljs-keyword">var</span> i, tid <span class="hljs-typename">int</span>

	<span class="hljs-keyword">for</span> _, gn := <span class="hljs-keyword">range</span> gl {
		<span class="hljs-keyword">if</span> !gn.IsBinary() &amp;&amp; !gn.IsLeaf() {
			<span class="hljs-keyword">for</span> i =<span class="hljs-number"> 0</span>; i &lt; <span class="hljs-built_in">len</span>(gn.Children<span class="hljs-number">)-1</span>; i++ {
				tn = M[gn.Children[i].Id]
				tid = tn.Id
				b[tid] = appendCopy(tn, b[tid], gn.Children[i], <span class="hljs-constant">true</span>)
				tn = lca(tn, M[gn.Children[i<span class="hljs-number">+1</span>].Id])
				tid = tn.Id
				b[tid] = appendCopy(tn, b[tid], gn.Children[i], <span class="hljs-constant">false</span>)
			}
			tn = M[gn.Children[i].Id]
			tid = tn.Id
			b[tid] = appendCopy(tn, b[tid], gn.Children[i], <span class="hljs-constant">true</span>)
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>4) Using Euler Tour of species tree to find
the corresponding Euler Tour <code>a[g]</code> (<code>a[g.Id]</code> in fact)
of every <code>I^*(g)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	visit := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">bool</span>, <span class="hljs-built_in">len</span>(sl))
	a := <span class="hljs-built_in">make</span>([][]*Node, <span class="hljs-built_in">len</span>(gl))
	<span class="hljs-keyword">var</span> gn, sn *Node
	tn = st.Node
	<span class="hljs-keyword">for</span> {
		tid = tn.Id
		visit[tid] = <span class="hljs-constant">true</span>
		<span class="hljs-keyword">for</span> _, sn = <span class="hljs-keyword">range</span> b[tid] {</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>In step 3), we use <code>sn.Father = g</code>
to indicates that <code>sn</code> is in the tree <code>I^*(g)</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			gn = sn.Father

			a[gn.Id] = <span class="hljs-built_in">append</span>(a[gn.Id], sn)
		}
		<span class="hljs-keyword">switch</span> {
		<span class="hljs-keyword">case</span> tn.IsLeaf():
			tn = tn.Father
		<span class="hljs-keyword">case</span> !visit[tn.Children<span class="hljs-number">[0</span>].Id]:
			tn = tn.Children<span class="hljs-number">[0</span>]
		<span class="hljs-keyword">case</span> !visit[tn.Children<span class="hljs-number">[1</span>].Id]:
			tn = tn.Children<span class="hljs-number">[1</span>]
		<span class="hljs-keyword">default</span>:
			tn = tn.Father
		}
		<span class="hljs-keyword">if</span> tn == <span class="hljs-constant">nil</span> {
			<span class="hljs-keyword">break</span>
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>5) Finally, reconstruct <code>I^*(g)</code> using its Euler Tour
<code>a[g]</code> (<code>a[g.Id]</code>). Notice that <code>I^*(g)</code> is just the
reconstructed tree with root <code>a[g][0]</code> (<code>a[g.Id][0]</code>).</p>

            </div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>use Eulor Tour to reconstruct the sub-tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	reconstruct := <span class="hljs-keyword">func</span>(l []*Node) {
		addchild := <span class="hljs-keyword">func</span>(f, n *Node) {
			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(f.Children) ==<span class="hljs-number"> 0</span> || f.Children[<span class="hljs-built_in">len</span>(f.Children<span class="hljs-number">)-1</span>] != n {
				f.AddChild(n)
			}
		}
		<span class="hljs-keyword">var</span> x, y *Node
		<span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; <span class="hljs-built_in">len</span>(l<span class="hljs-number">)-1</span>; i++ {
			x = l[i]
			y = l[i<span class="hljs-number">+1</span>]
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-keyword">case</span> x.Level &lt; y.Level:
				addchild(x, y)
			<span class="hljs-keyword">case</span> x.Level &gt; y.Level:
				addchild(y, x)
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>If <code>x.Level == y.Level</code>
and <code>x, y</code> are consective in Euler Tour
thus <code>x == y</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		}

	}

	<span class="hljs-keyword">for</span> i, gn = <span class="hljs-keyword">range</span> gl {
		<span class="hljs-keyword">if</span> !gn.IsBinary() &amp;&amp; !gn.IsLeaf() {
			<span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> a[i] {
				n.Father = <span class="hljs-constant">nil</span>
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>frist, reconstruct <code>I^*(g)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			reconstruct(a[i])</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>then, refine it</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			refine(a[i]<span class="hljs-number">[0</span>])</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>finally, replace the original subtree by the refined one.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			gn.replaceBy(a[i]<span class="hljs-number">[0</span>])
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>some clean up</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	gt.Update()
	<span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> gt.Nodes {</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>remove node with out-degree 1.
just by replace node with its single children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Children) ==<span class="hljs-number"> 1</span> {
			n.replaceBy(n.Children<span class="hljs-number">[0</span>])
		}

		<span class="hljs-keyword">if</span> !n.IsLeaf() {
			n.Name = <span class="hljs-string">""</span>
		}
	}
	gt.Update()
	<span class="hljs-keyword">return</span> <span class="hljs-constant">nil</span>
}</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Refine gene tree node to achieve minimal duplication + loss cost</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">func</span> minDupPlusLoss(root *Node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>bottom up, update <code>a, b</code> on each edge with length <code>d</code>
i.e. <code>d = node.Level - father.Level</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	update := <span class="hljs-keyword">func</span>(a, b, d <span class="hljs-typename">int</span>) (<span class="hljs-typename">int</span>, <span class="hljs-typename">int</span>) {
		<span class="hljs-keyword">switch</span> {
		<span class="hljs-keyword">case</span> d &gt;<span class="hljs-number"> 2</span>:
			<span class="hljs-keyword">return</span><span class="hljs-number"> 0</span>,<span class="hljs-number"> 0</span>
		<span class="hljs-keyword">case</span> d ==<span class="hljs-number"> 2</span>:
			<span class="hljs-keyword">return</span><span class="hljs-number"> 0</span>, a
		<span class="hljs-keyword">case</span> d ==<span class="hljs-number"> 1</span>:
			<span class="hljs-keyword">return</span> a, b
		<span class="hljs-keyword">default</span>:
			<span class="hljs-built_in">panic</span>(<span class="hljs-string">"Incorrect level difference."</span>)
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>bottom up, get <code>a, b</code> from <code>w, a1, b1, a2, b2</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	getab := <span class="hljs-keyword">func</span>(w <span class="hljs-typename">int</span>, args ...<span class="hljs-typename">int</span>) (<span class="hljs-typename">int</span>, <span class="hljs-typename">int</span>) {
		sort.Ints(args)
		<span class="hljs-keyword">return</span> w + args<span class="hljs-number">[1</span>], w + args<span class="hljs-number">[2</span>]
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>don’t update level!
keep the level value from original species tree!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	nl := root.Post2List()
	size := <span class="hljs-built_in">len</span>(nl)
	A := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	B := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	W := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>use <code>P[i]</code> to denote the preimages of node <code>i</code>,
which are stored in <code>node.Ext</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	P := <span class="hljs-built_in">make</span>([][]*Node, size)

	<span class="hljs-keyword">var</span> a1, b1, a2, b2, d1, d2 <span class="hljs-typename">int</span>
	<span class="hljs-keyword">var</span> node, father, lchild, rchild *Node
	<span class="hljs-keyword">var</span> i, t <span class="hljs-typename">int</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Now calculate <code>a, b</code>, and <code>w</code> for each node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> i, node = <span class="hljs-keyword">range</span> nl {
		node.Id = i
		<span class="hljs-keyword">if</span> node.Ext != <span class="hljs-constant">nil</span> {
			P[i] = node.Ext.([]*Node)
			node.Ext = <span class="hljs-constant">nil</span>
		}

		W[i] = <span class="hljs-built_in">len</span>(P[i])
		<span class="hljs-keyword">if</span> node.IsLeaf() {
			A[i] = W[i] -<span class="hljs-number"> 1</span> <span class="hljs-comment">// remove background tree</span>
			B[i] = A[i]
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(node.Children) ==<span class="hljs-number"> 2</span> {
				rchild = node.Children<span class="hljs-number">[1</span>]
				a2, b2 = A[rchild.Id], B[rchild.Id]
				d2 = rchild.Level - node.Level
				a2, b2 = update(a2, b2, d2)
			} <span class="hljs-keyword">else</span> {
				a2, b2 =<span class="hljs-number"> 0</span>,<span class="hljs-number"> 0</span>
			}

			lchild = node.Children<span class="hljs-number">[0</span>]
			a1, b1 = A[lchild.Id], B[lchild.Id]
			d1 = lchild.Level - node.Level
			a1, b1 = update(a1, b1, d1)

			A[i], B[i] = getab(W[i], a1, b1, a2, b2)
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p><code>K[i]</code>: the number of gene lineages entering the
incoming edge of <code>node[i]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	K := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p><code>T[i]</code>: the number of gene lineages leaving the
incoming branch of <code>node[i]</code>, and entering <code>node[i]</code>.
i.e. the number of gene copies that <code>node[i]</code> inherited.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	T := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>use <code>Fid[i]</code> to store the <code>nl[i].Father.Id</code>,
as <code>nl[i].Father</code> will change later.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	Fid := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>There is no extra lineage at root, thus <code>t = 0</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	T[size<span class="hljs-number">-1</span>] =<span class="hljs-number"> 0</span>
	K[size<span class="hljs-number">-1</span>] = project<span class="hljs-number">(0</span>, A[size<span class="hljs-number">-1</span>], B[size<span class="hljs-number">-1</span>])</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Now, compute the number of incoming and outgoing
extra lineages at each node.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> i = size -<span class="hljs-number"> 2</span>; i &gt;=<span class="hljs-number"> 0</span>; i-- {
		node = nl[i]
		father = node.Father
		Fid[i] = father.Id
		t = K[father.Id] - W[father.Id]</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>If level difference &gt; 2, it’s fine to
loss all extra lineages</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> node.Level-father.Level &gt;<span class="hljs-number"> 2</span> {
			t =<span class="hljs-number"> 0</span>
		}
		T[i] = t
		K[i] = project(t, A[i], B[i])
	}
	simpleConstruct(nl, K, T, W, Fid, P)
}</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Refine a gene tree node by minimizing
duplication cost first, then gene loss cost.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">func</span> minDupThenLoss(root *Node) {
	nl := root.Post2List()
	size := <span class="hljs-built_in">len</span>(nl)</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p><code>A[i] = W[i] - 1</code> for leaf, otherwise
<code>A[i]</code> is the min of <code>B[lchild]</code>, <code>B[rchild]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	A := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p><code>B[i] = W[i] - 1</code> for leaf, otherwise
<code>B[i]</code> is the max of <code>B[lchild]</code>, <code>B[rchild]</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	B := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	W := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	P := <span class="hljs-built_in">make</span>([][]*Node, size)
	<span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> nl {
		n.Id = i
		<span class="hljs-keyword">if</span> n.Ext != <span class="hljs-constant">nil</span> {
			P[i] = n.Ext.([]*Node)
			n.Ext = <span class="hljs-constant">nil</span>
		}
		W[i] = <span class="hljs-built_in">len</span>(P[i])
		nchild := <span class="hljs-built_in">len</span>(n.Children)
		<span class="hljs-keyword">switch</span> {
		<span class="hljs-keyword">case</span> nchild ==<span class="hljs-number"> 0</span>:
			A[i] = W[i] -<span class="hljs-number"> 1</span>
			B[i] = W[i] -<span class="hljs-number"> 1</span>
		<span class="hljs-keyword">case</span> nchild ==<span class="hljs-number"> 1</span>:
			A[i] = W[i] +<span class="hljs-number"> 0</span>
			B[i] = W[i] + B[n.Children<span class="hljs-number">[0</span>].Id]
		<span class="hljs-keyword">case</span> nchild ==<span class="hljs-number"> 2</span>:
			b1 := B[n.Children<span class="hljs-number">[0</span>].Id]
			b2 := B[n.Children<span class="hljs-number">[1</span>].Id]
			<span class="hljs-keyword">if</span> b1 &gt; b2 {
				A[i] = b2
				B[i] = b1
			} <span class="hljs-keyword">else</span> {
				A[i] = b1
				B[i] = b2
			}
			A[i] += W[i]
			B[i] += W[i]
		<span class="hljs-keyword">default</span>:
			<span class="hljs-built_in">panic</span>(<span class="hljs-string">"Incorrect number of children."</span>)
		}
	}
	Fid := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	<span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; size<span class="hljs-number">-1</span>; i++ {
		Fid[i] = nl[i].Father.Id
	}

	T := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	K := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	T[size<span class="hljs-number">-1</span>] =<span class="hljs-number"> 0</span>
	K[size<span class="hljs-number">-1</span>] = project<span class="hljs-number">(0</span>, A[size<span class="hljs-number">-1</span>], B[size<span class="hljs-number">-1</span>])
	<span class="hljs-keyword">for</span> i := size -<span class="hljs-number"> 2</span>; i &gt;=<span class="hljs-number"> 0</span>; i-- {
		n := nl[i]
		T[i] = K[n.Father.Id] - W[n.Father.Id]
		K[i] = project(T[i], A[i], B[i])
	}

	simpleConstruct(nl, K, T, W, Fid, P)
}</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Refine a gene tree node by minimizing
gene loss cost first, then duplication cost.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">func</span> minLossThenDup(root *Node) {
	nl := root.Post2List()
	size := <span class="hljs-built_in">len</span>(nl)
	K := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	W := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	P := <span class="hljs-built_in">make</span>([][]*Node, size)
	<span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> nl {
		n.Id = i
		<span class="hljs-keyword">if</span> n.Ext != <span class="hljs-constant">nil</span> {
			P[i] = n.Ext.([]*Node)
			n.Ext = <span class="hljs-constant">nil</span>
		}
		W[i] = <span class="hljs-built_in">len</span>(P[i])
		nchild := <span class="hljs-built_in">len</span>(n.Children)
		<span class="hljs-keyword">switch</span> nchild {
		<span class="hljs-keyword">case</span><span class="hljs-number"> 0</span>:
			K[i] = W[i] -<span class="hljs-number"> 1</span>
		<span class="hljs-keyword">case</span><span class="hljs-number"> 1</span>:
			K[i] = W[i]
		<span class="hljs-keyword">case</span><span class="hljs-number"> 2</span>:
			<span class="hljs-keyword">var</span> v1, v2 <span class="hljs-typename">int</span>
			<span class="hljs-keyword">if</span> n.Children<span class="hljs-number">[0</span>].Level-n.Level ==<span class="hljs-number"> 1</span> {
				v1 = K[n.Children<span class="hljs-number">[0</span>].Id]
			} <span class="hljs-comment">// else v1 = 0</span>
			<span class="hljs-keyword">if</span> n.Children<span class="hljs-number">[1</span>].Level-n.Level ==<span class="hljs-number"> 1</span> {
				v2 = K[n.Children<span class="hljs-number">[1</span>].Id]
			} <span class="hljs-comment">// else v2 = 0</span>
			<span class="hljs-keyword">if</span> v1 &gt; v2 {
				K[i] = v2
			} <span class="hljs-keyword">else</span> {
				K[i] = v1
			}
			K[i] += W[i]
		}
	}

	Fid := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	<span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; size<span class="hljs-number">-1</span>; i++ {
		Fid[i] = nl[i].Father.Id
	}

	T := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
	T[size<span class="hljs-number">-1</span>] =<span class="hljs-number"> 0</span>
	<span class="hljs-keyword">for</span> i := size -<span class="hljs-number"> 2</span>; i &gt;=<span class="hljs-number"> 0</span>; i-- {
		n := nl[i]
		T[i] = K[n.Father.Id] - W[n.Father.Id]
	}

	simpleConstruct(nl, K, T, W, Fid, P)
}</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>DP + C
Now should be replaced by Affine method, which is faster in extreme case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">func</span> weightedCost(wdup, wdc <span class="hljs-typename">float64</span>) <span class="hljs-keyword">func</span>(*Node) {
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">func</span>(root *Node) {
		nl := root.Post2List()
		size := <span class="hljs-built_in">len</span>(nl)
		M := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
		W := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
		P := <span class="hljs-built_in">make</span>([][]*Node, size)
		U := <span class="hljs-built_in">make</span>([][]<span class="hljs-typename">float64</span>, size)
		I := <span class="hljs-built_in">make</span>([][]<span class="hljs-typename">int</span>, size)
		<span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> nl {
			n.Id = i
			<span class="hljs-keyword">if</span> n.Ext != <span class="hljs-constant">nil</span> {
				P[i] = n.Ext.([]*Node)
				n.Ext = <span class="hljs-constant">nil</span>
			}
			W[i] = <span class="hljs-built_in">len</span>(P[i])
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(n.Children) ==<span class="hljs-number"> 0</span>:
				M[i] = W[i] -<span class="hljs-number"> 1</span>
			<span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(n.Children) ==<span class="hljs-number"> 1</span>:
				M[i] = M[n.Children<span class="hljs-number">[0</span>].Id] + W[i]
			<span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(n.Children) ==<span class="hljs-number"> 2</span>:
				v1 := M[n.Children<span class="hljs-number">[0</span>].Id]
				v2 := M[n.Children<span class="hljs-number">[1</span>].Id]
				<span class="hljs-keyword">if</span> v1 &gt; v2 {
					M[i] = v1
				} <span class="hljs-keyword">else</span> {
					M[i] = v2
				}
				M[i] += W[i]
			<span class="hljs-keyword">default</span>:
				<span class="hljs-built_in">panic</span>(<span class="hljs-string">"Not a binary node!"</span>)
			}
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>A special case is that there is
only one node in I^*(g).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> size ==<span class="hljs-number"> 1</span> {
			K := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
			T := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
			T<span class="hljs-number">[0</span>] =<span class="hljs-number"> 0</span>
			K<span class="hljs-number">[0</span>] = W<span class="hljs-number">[0</span>] -<span class="hljs-number"> 1</span>
			simpleConstruct(nl, K, T, W, <span class="hljs-constant">nil</span>, P)
			<span class="hljs-keyword">return</span>
		}

		mul := M[size<span class="hljs-number">-1</span>]
		C := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">float64</span>, mul<span class="hljs-number">+1</span>)

		min := <span class="hljs-keyword">func</span>(args ...<span class="hljs-typename">float64</span>) <span class="hljs-typename">float64</span> {
			m := args<span class="hljs-number">[0</span>]
			<span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 1</span>; i &lt; <span class="hljs-built_in">len</span>(args); i++ {
				<span class="hljs-keyword">if</span> args[i] &lt; m {
					m = args[i]
				}
			}
			<span class="hljs-keyword">return</span> m
		}

		getCost := <span class="hljs-keyword">func</span>(in, out, d <span class="hljs-typename">int</span>) <span class="hljs-typename">float64</span> {
			m := min(<span class="hljs-typename">float64</span>(d)*wdc, wdup)
			<span class="hljs-keyword">if</span> in &gt;= out {
				<span class="hljs-keyword">return</span> m * <span class="hljs-typename">float64</span>(out)
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> m*<span class="hljs-typename">float64</span>(in) + wdup*<span class="hljs-typename">float64</span>(out-in)
			}
		}

		getMin := <span class="hljs-keyword">func</span>(ind, in, d <span class="hljs-typename">int</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>multiplicity</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			w := W[ind]</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>list of cost</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			l := C</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>(p, m): the cost m with p outgoing lineages
in branch ind with in incoming lineages.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			p, m := w, getCost(in, w, d)+l[w]
			<span class="hljs-keyword">for</span> out := w +<span class="hljs-number"> 1</span>; out &lt;= M[ind]; out++ {
				t := getCost(in, out, d) + l[out]
				<span class="hljs-keyword">if</span> t &lt; m {
					p, m = out, t
				}
			}
			U[ind][in] = m
			I[ind][in] = p
		}

		getC := <span class="hljs-keyword">func</span>(i, w <span class="hljs-typename">int</span>) {
			n := nl[i]
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(n.Children) ==<span class="hljs-number"> 1</span>:
				lu := U[n.Children<span class="hljs-number">[0</span>].Id]
				<span class="hljs-keyword">for</span> j := w; j &lt;= M[i]; j++ {
					C[j] = lu[j-w]
				}
			<span class="hljs-keyword">case</span> <span class="hljs-built_in">len</span>(n.Children) ==<span class="hljs-number"> 2</span>:
				lu := U[n.Children<span class="hljs-number">[0</span>].Id]
				ru := U[n.Children<span class="hljs-number">[1</span>].Id]
				<span class="hljs-keyword">for</span> j := w; j &lt;= M[i]; j++ {
					C[j] = lu[j-w] + ru[j-w]
				}
			}
		}

		Fid := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
		<span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; size<span class="hljs-number">-1</span>; i++ {
			Fid[i] = nl[i].Father.Id
		}

		<span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> nl {
			w := W[i]
			<span class="hljs-keyword">switch</span> {
			<span class="hljs-keyword">case</span> n.IsLeaf():
				U[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">float64</span>, M[Fid[i]]-W[Fid[i]<span class="hljs-number">]+1</span>)
				I[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, M[Fid[i]]-W[Fid[i]<span class="hljs-number">]+1</span>)
				d := n.Level - n.Father.Level
				<span class="hljs-keyword">for</span> j :=<span class="hljs-number"> 0</span>; j &lt;= M[Fid[i]]-W[Fid[i]]; j++ {
					U[i][j] = getCost(j, w<span class="hljs-number">-1</span>, d)
					I[i][j] = w -<span class="hljs-number"> 1</span>
				}
			<span class="hljs-keyword">case</span> n.IsRoot():
				U[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">float64</span>,<span class="hljs-number"> 1</span>)
				I[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>,<span class="hljs-number"> 1</span>)
				getC(i, w)
				getMin(i,<span class="hljs-number"> 0</span>,<span class="hljs-number"> 0</span>)
			<span class="hljs-keyword">default</span>: <span class="hljs-comment">// internal but not root</span>
				U[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">float64</span>, M[Fid[i]]-W[Fid[i]<span class="hljs-number">]+1</span>)
				I[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, M[Fid[i]]-W[Fid[i]<span class="hljs-number">]+1</span>)
				getC(i, w)
				d := n.Level - n.Father.Level
				<span class="hljs-keyword">for</span> j :=<span class="hljs-number"> 0</span>; j &lt;= M[Fid[i]]-W[Fid[i]]; j++ {
					getMin(i, j, d)
				}
			}
		}

		K := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
		T := <span class="hljs-built_in">make</span>([]<span class="hljs-typename">int</span>, size)
		T[size<span class="hljs-number">-1</span>] =<span class="hljs-number"> 0</span>
		K[size<span class="hljs-number">-1</span>] = I[size<span class="hljs-number">-1</span>]<span class="hljs-number">[0</span>]
		<span class="hljs-keyword">for</span> i := size -<span class="hljs-number"> 2</span>; i &gt;=<span class="hljs-number"> 0</span>; i-- {
			n := nl[i]
			T[i] = K[n.Father.Id] - W[n.Father.Id]</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Important!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			d := n.Level - n.Father.Level
			<span class="hljs-keyword">if</span> <span class="hljs-typename">float64</span>(d)*wdc &gt; wdup {
				T[i] =<span class="hljs-number"> 0</span>
			}
			K[i] = I[i][T[i]]
		}

		simpleConstruct(nl, K, T, W, Fid, P)
	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>A simple reconstruction of subtree with
the information on <code>I^*(g)</code>.</p>
<p>All duplication occurs on the background tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">func</span> simpleConstruct(nl []*Node, K, T, W, Fid []<span class="hljs-typename">int</span>, P [][]*Node) {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>insert nodes onto the edge <code>(node.Father, node)</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	insertNode := <span class="hljs-keyword">func</span>(node *Node, nodes []*Node) {
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nodes) ==<span class="hljs-number"> 0</span> {
			<span class="hljs-keyword">return</span>
		}
		lchild := newNode()
		lchild.replaceBy(node)
		node.Children = <span class="hljs-constant">nil</span>
		<span class="hljs-keyword">for</span> i :=<span class="hljs-number"> 0</span>; i &lt; <span class="hljs-built_in">len</span>(nodes<span class="hljs-number">)-1</span>; i++ {
			nnode := newNode()
			nnode.AddChild(lchild)
			nnode.AddChild(nodes[i])
			lchild = nnode
		}
		node.AddChild(lchild)
		node.AddChild(nodes[<span class="hljs-built_in">len</span>(nodes<span class="hljs-number">)-1</span>])
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>every <code>node = nl[i]</code> in the tree <code>I^*(g)</code>
may has multiple extra copies,
we store them in the list <code>nodes[i]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	nodes := <span class="hljs-built_in">make</span>([][]*Node, <span class="hljs-built_in">len</span>(K))

	<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(K) -<span class="hljs-number"> 1</span>; i &gt;=<span class="hljs-number"> 0</span>; i-- {</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p><code>K[i]</code> extra copies.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		nodes[i] = <span class="hljs-built_in">make</span>([]*Node, K[i])
		<span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> nodes[i] {
			nodes[i][j] = newNode()
		}

		node := nl[i]</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>we need to replace the leaves with original
children of non-binary gene tree node,
such that we can embed the refined tree into
the original gene tree.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> W[i] &gt;<span class="hljs-number"> 0</span> {
			<span class="hljs-keyword">if</span> node.IsLeaf() &amp;&amp; K[i] != W[i<span class="hljs-number">]-1</span> {
				<span class="hljs-built_in">panic</span>(<span class="hljs-string">"Something wrong."</span>)
			} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> !node.IsLeaf() &amp;&amp; K[i] &lt; W[i] {
				<span class="hljs-built_in">panic</span>(<span class="hljs-string">"Something wrong too."</span>)
			}
			<span class="hljs-keyword">if</span> node.IsLeaf() {
				<span class="hljs-keyword">for</span> j, n := <span class="hljs-keyword">range</span> nodes[i] {
					n.replaceBy(P[i][j<span class="hljs-number">+1</span>])
				}
				node.replaceBy(P[i]<span class="hljs-number">[0</span>])
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">for</span> j, pnode := <span class="hljs-keyword">range</span> P[i] {
					nodes[i][K[i<span class="hljs-number">]-1</span>-j].replaceBy(pnode)
				}
			}
		}

		<span class="hljs-keyword">if</span> node.Father != <span class="hljs-constant">nil</span> {
			fid := Fid[i]</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Connect extra nodes at <code>n</code> to the nodes
at <code>n.Father</code> as much as possible.
There are <code>T[i]</code> lineages inherited from <code>n.father</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">for</span> j :=<span class="hljs-number"> 0</span>; j &lt; T[i] &amp;&amp; j &lt; K[i]; j++ {
				nodes[fid][j].AddChild(nodes[i][j])
			}
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>the rest nodes are just duplicated from background tree.
i.e. from the <code>node = nl[i]</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> T[i] &lt; K[i] {
			insertNode(node, nodes[i][T[i]:K[i]])
		}
	}

	<span class="hljs-keyword">for</span> _, n := <span class="hljs-keyword">range</span> nl {
		<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(n.Children) ==<span class="hljs-number"> 1</span> {
			n.replaceBy(n.Children<span class="hljs-number">[0</span>])
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>This step has been moved to the caller function!</p>

            </div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>// now replace the original non-binary tree node with root of I^*(g)</p>

            </div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>replaceNode(root.Map, root)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
